# ~/streamcache/conf/nginx.conf
# ----- ENV (main context only) -----
env CACHE_MAX_BYTES;
env CACHE_LOW_WATERMARK_BYTES;
env RANGE_TEE_THRESHOLD;
env PROGRESS_FLUSH_BYTES;
env FOLLOWER_WAIT_MAX;
env FOLLOWER_POLL_MS;
env CACHE_JANITOR_INTERVAL;
env ALLOWED_HOSTS;
env DISABLE_SSL_VERIFY;
env LOG_VERBOSE;
env RESOLVE_TTL;
env TMP_RETENTION_SECS;

worker_processes auto;

events {
  worker_connections 2048;
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  sendfile        on;
  tcp_nopush      on;
  tcp_nodelay     on;
  keepalive_timeout 65;

  # Lua module paths (for resty.http)
  lua_package_path  "/usr/local/openresty/site/lualib/?.lua;/usr/local/openresty/lualib/?.lua;;";
  lua_package_cpath "/usr/local/openresty/site/lualib/?.so;/usr/local/openresty/lualib/?.so;;";

  # DNS for upstreams
  resolver 8.8.8.8 1.1.1.1 ipv6=off valid=300s;
  resolver_timeout 5s;

  # Verify HTTPS using the system CA bundle
  lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
  lua_ssl_verify_depth 5;

  # Logs to Docker (now with request id, decision, and xcache)
  log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                  '$status $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_range" '
                  'rt=$request_time up_rt=$upstream_response_time '
                  'rid=$request_id decision=$sc_decision xcache=$sent_http_x_cache';

  access_log /dev/stdout main;
  error_log  /dev/stderr info;

  # Declare $sc_decision at http level so it's usable in log_format
  map $request_id $sc_decision { default ""; }

  # Shared dicts for streamcache
  lua_shared_dict inflight 10m;  # prevent duplicate full fetches
  lua_shared_dict access   50m;  # last-access timestamps (LRU)
  lua_shared_dict resolved 10m;  # kept for optional hints
  lua_shared_dict progress 10m;  # follower progress
  lua_shared_dict totals   10m;  # total size hints

  client_max_body_size 0;

  # --- Janitor + tmp-janitor ---
  init_worker_by_lua_block {
    local ngx = ngx
    local access = ngx.shared.access
    local inflight = ngx.shared.inflight
    local progress = ngx.shared.progress

    local CACHE_DIR = "/var/cache/streamcache/files"
    local META_DIR  = "/var/cache/streamcache/meta"
    local TMP_DIR   = "/var/cache/streamcache/tmp"

    local function b2human(n)
      if not n or n < 0 then return "0 B" end
      local u={"B","KB","MB","GB","TB","PB"} local i=1
      while n >= 1024 and i < #u do n = n/1024; i = i + 1 end
      return string.format("%.2f %s", n, u[i])
    end

    local VERBOSE = (os.getenv("LOG_VERBOSE") == "1")

    local function file_size(p)
      local f = io.open(p, "rb")
      if not f then return 0 end
      local sz = f:seek("end"); f:close()
      return sz or 0
    end

    local function parse_meta(p)
      local f = io.open(p, "rb")
      if not f then return nil end
      local size, last = nil, nil
      for line in f:lines() do
        local k,v = line:match("^([a-z_]+)=(.+)$")
        if k == "size" then size = tonumber(v)
        elseif k == "last_access" then last = tonumber(v)
        end
      end
      f:close(); return size, last
    end

    local function file_mtime(p)
      local h = io.popen('stat -c %Y "'..p..'" 2>/dev/null')
      if not h then return nil end
      local t = h:read("*l"); h:close()
      return tonumber(t)
    end

    local function janitor(premature)
      if premature then return end
      local MAX = tonumber(os.getenv("CACHE_MAX_BYTES") or "") or (500 * 1024^3)
      local LOW = tonumber(os.getenv("CACHE_LOW_WATERMARK_BYTES") or "") or (450 * 1024^3)
      local t0 = ngx.now()

      os.execute("mkdir -p " .. CACHE_DIR .. " " .. META_DIR)

      local files, total = {}, 0
      local p = io.popen("ls -1 " .. CACHE_DIR .. " 2>/dev/null")
      if p then
        for name in p:lines() do
          local key = name
          local path = CACHE_DIR .. "/" .. name
          local meta_path = META_DIR .. "/" .. key .. ".meta"
          local size, last = parse_meta(meta_path)
          if not size then size = file_size(path) end
          if not last then last = access:get(key) or 0 end
          files[#files+1] = {key=key, path=path, meta=meta_path, size=size, last=last}
          total = total + (size or 0)
        end
        p:close()
      end

      if VERBOSE then
        ngx.log(ngx.INFO, string.format(
          "[streamcache] janitor check: total=%s (%d bytes), max=%s, low=%s, files=%d",
          b2human(total), total, b2human(MAX), b2human(LOW), #files))
      else
        ngx.log(ngx.NOTICE, string.format(
          "[streamcache] janitor: total=%s, max=%s, low=%s",
          b2human(total), b2human(MAX), b2human(LOW)))
      end

      if total <= MAX then return end

      table.sort(files, function(a,b) return (a.last or 0) < (b.last or 0) end)

      local removed_files, removed_bytes = 0, 0
      for _,f in ipairs(files) do
        if total <= LOW then break end
        os.remove(f.path); os.remove(f.meta); access:delete(f.key)
        total = total - (f.size or 0)
        removed_files = removed_files + 1
        removed_bytes = removed_bytes + (f.size or 0)
        if VERBOSE then
          ngx.log(ngx.INFO, string.format("[streamcache] evict: key=%s size=%s",
            f.key, b2human(f.size or 0)))
        end
      end

      ngx.log(ngx.NOTICE, string.format(
        "[streamcache] eviction done in %.2fs: removed %d (%s), new total=%s",
        ngx.now() - t0, removed_files, b2human(removed_bytes), b2human(total)))
    end

    -- tmp-janitor: purge orphaned .part files older than TMP_RETENTION_SECS and not inflight
    local function janitor_tmp(premature)
      if premature then return end
      local keep = tonumber(os.getenv("TMP_RETENTION_SECS") or "") or 86400 -- 24h default
      os.execute("mkdir -p " .. TMP_DIR)
      local p = io.popen("ls -1 " .. TMP_DIR .. " 2>/dev/null")
      if not p then return end
      local removed = 0
      for name in p:lines() do
        local key = name:match("^(%x+)%.part$")
        if key then
          local path = TMP_DIR .. "/" .. name
          local mt   = file_mtime(path) or 0
          local age  = ngx.now() - mt
          local infl = inflight:get(key)
          local prog = progress:get(key)
          if (not infl) and (not prog or prog == 0) and age > keep then
            os.remove(path); removed = removed + 1
            if VERBOSE then ngx.log(ngx.INFO, "[streamcache] tmp-janitor removed ", name) end
          end
        end
      end
      p:close()
      if removed > 0 then
        ngx.log(ngx.NOTICE, "[streamcache] tmp-janitor purged ", removed, " stale .part files")
      end
    end

    local interval = tonumber(os.getenv("CACHE_JANITOR_INTERVAL") or "") or 60

    if ngx.worker.id() == 0 then
      local MAX = tonumber(os.getenv("CACHE_MAX_BYTES") or "") or (500 * 1024^3)
      local LOW = tonumber(os.getenv("CACHE_LOW_WATERMARK_BYTES") or "") or (450 * 1024^3)
      ngx.log(ngx.NOTICE, string.format(
        "[streamcache] start: max=%s (%d), low=%s (%d), interval=%ds, verbose=%s",
        b2human(MAX), MAX, b2human(LOW), LOW, interval, tostring(VERBOSE)))

      local ok, err = ngx.timer.every(interval, janitor)
      if not ok then ngx.log(ngx.ERR, "janitor timer failed: ", err) end

      local ok2, err2 = ngx.timer.every(interval, janitor_tmp)
      if not ok2 then ngx.log(ngx.ERR, "tmp-janitor timer failed: ", err2) end
    elseif VERBOSE then
      ngx.log(ngx.INFO, "[streamcache] worker " .. ngx.worker.id() .. " not leader; janitor disabled")
    end
  }

  include /etc/openresty/conf.d/*.conf;
}

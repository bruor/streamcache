# ~/streamcache/conf/nginx.conf

# ---------- ENV (main context only) ----------
env CACHE_MAX_BYTES;
env CACHE_LOW_WATERMARK_BYTES;
env CACHE_JANITOR_INTERVAL;
env ALLOWED_HOSTS;
env DISABLE_SSL_VERIFY;
env LOG_VERBOSE;
env RESOLVE_TTL;
# --------------------------------------------

worker_processes auto;

events {
    worker_connections 2048;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;

    # Lua module paths (for resty.http)
    lua_package_path "/usr/local/openresty/site/lualib/?.lua;/usr/local/openresty/lualib/?.lua;;";
    lua_package_cpath "/usr/local/openresty/site/lualib/?.so;/usr/local/openresty/lualib/?.so;;";

    # DNS for upstreams
    resolver 8.8.8.8 1.1.1.1 ipv6=off valid=300s;

    # Let Lua verify HTTPS using the system CA bundle
    lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    lua_ssl_verify_depth 5;

    # Logs to Docker
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_range" '
                    'rt=$request_time up_rt=$upstream_response_time';
    access_log /dev/stdout main;
    error_log  /dev/stderr info;

    # Shared dicts
    lua_shared_dict inflight 10m;   # prevent duplicate full fetches
    lua_shared_dict access  50m;    # last-access timestamps (LRU)
    lua_shared_dict resolved 10m;   # cache of resolved CDN URLs (per key)
    lua_shared_dict progress 10m;   # NEW
    lua_shared_dict totals   10m;   # NEW
    
    client_max_body_size 0;

    # ----- Human-readable logging + janitor registration -----
    init_worker_by_lua_block {
        local ngx = ngx
        local access = ngx.shared.access

        local CACHE_DIR = "/var/cache/streamcache/files"
        local META_DIR  = "/var/cache/streamcache/meta"

        local function b2human(n)
            if not n or n < 0 then return "0 B" end
            local units = {"B","KB","MB","GB","TB","PB"}
            local i = 1
            while n >= 1024 and i < #units do n = n / 1024; i = i + 1 end
            return string.format("%.2f %s", n, units[i])
        end

        local VERBOSE = (os.getenv("LOG_VERBOSE") == "1")

        local function file_size(path)
            local f = io.open(path, "rb"); if not f then return 0 end
            local sz = f:seek("end"); f:close(); return sz or 0
        end

        local function parse_meta(path)
            local f = io.open(path, "rb"); if not f then return nil end
            local size, last = nil, nil
            for line in f:lines() do
                local k, v = line:match("^([a-z_]+)=(.+)$")
                if k == "size" then size = tonumber(v)
                elseif k == "last_access" then last = tonumber(v)
                end
            end
            f:close()
            return size, last
        end

        local function janitor(premature)
            if premature then return end
            local MAX = tonumber(os.getenv("CACHE_MAX_BYTES") or "") or (500 * 1024^3)
            local LOW = tonumber(os.getenv("CACHE_LOW_WATERMARK_BYTES") or "") or (450 * 1024^3)
            local t0 = ngx.now()

            os.execute("mkdir -p " .. CACHE_DIR .. " " .. META_DIR)

            local files, total = {}, 0
            local p = io.popen("ls -1 " .. CACHE_DIR .. " 2>/dev/null")
            if p then
                for name in p:lines() do
                    local key = name
                    local path = CACHE_DIR .. "/" .. name
                    local meta_path = META_DIR .. "/" .. key .. ".meta"
                    local size, last = parse_meta(meta_path)
                    if not size then size = file_size(path) end
                    if not last then last = access:get(key) or 0 end
                    files[#files+1] = {key=key, path=path, meta=meta_path, size=size, last=last}
                    total = total + (size or 0)
                end
                p:close()
            end

            if VERBOSE then
                ngx.log(ngx.INFO, string.format(
                    "[streamcache] janitor check: total=%s (%d bytes), max=%s, low=%s, files=%d",
                    b2human(total), total, b2human(MAX), b2human(LOW), #files))
            else
                ngx.log(ngx.NOTICE, string.format(
                    "[streamcache] janitor: total=%s, max=%s, low=%s",
                    b2human(total), b2human(MAX), b2human(LOW)))
            end

            if total <= MAX then return end

            table.sort(files, function(a,b) return (a.last or 0) < (b.last or 0) end)

            local removed_files, removed_bytes = 0, 0
            for _, f in ipairs(files) do
                if total <= LOW then break end
                os.remove(f.path)
                os.remove(f.meta)
                access:delete(f.key)
                total = total - (f.size or 0)
                removed_files = removed_files + 1
                removed_bytes = removed_bytes + (f.size or 0)
                if VERBOSE then
                    ngx.log(ngx.INFO, string.format(
                        "[streamcache] evict: key=%s size=%s", f.key, b2human(f.size or 0)))
                end
            end

            ngx.log(ngx.NOTICE, string.format(
                "[streamcache] eviction done in %.2fs: removed %d (%s), new total=%s",
                ngx.now() - t0, removed_files, b2human(removed_bytes), b2human(total)))
        end

        local MAX = tonumber(os.getenv("CACHE_MAX_BYTES") or "") or (500 * 1024^3)
        local LOW = tonumber(os.getenv("CACHE_LOW_WATERMARK_BYTES") or "") or (450 * 1024^3)
        local interval = tonumber(os.getenv("CACHE_JANITOR_INTERVAL") or "") or 60

        if ngx.worker.id() == 0 then
          ngx.log(ngx.NOTICE, string.format(
              "[streamcache] start: max=%s (%d), low=%s (%d), interval=%ds, verbose=%s",
              b2human(MAX), MAX, b2human(LOW), LOW, interval, tostring(VERBOSE)))

          local ok, err = ngx.timer.every(interval, janitor)
          if not ok then ngx.log(ngx.ERR, "janitor timer failed: ", err) end
        else
          if VERBOSE then
              ngx.log(ngx.INFO, "[streamcache] worker " .. ngx.worker.id() .. " not leader; janitor disabled")
          end
        end

    }

    include /etc/openresty/conf.d/*.conf;
}

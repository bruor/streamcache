server {
    listen 8080;
    server_name _;

    # Carry decoded upstream URL to proxy_pass when needed
    set $upstream_url "";

    # Serve cached files directly; Nginx static supports Range natively
    location /cache/ {
        internal;
        alias /var/cache/streamcache/files/;
        add_header Accept-Ranges bytes always;
    }

    # Main endpoint: /u/<BASE64URL-ENCODED-ORIGINAL-URL>
    location ~ ^/u/(?<b64>[-_A-Za-z0-9=]+)$ {
        content_by_lua_block {
            local ngx = ngx
            local os  = os
            local http = require "resty.http"

            -- ===== Helpers =====
            local VERBOSE = (os.getenv("LOG_VERBOSE") == "1")
            local RESOLVE_TTL = tonumber(os.getenv("RESOLVE_TTL") or "") or 60

            local function b2human(n)
                if not n or n < 0 then return "0 B" end
                local units = {"B","KB","MB","GB","TB","PB"}
                local i = 1
                while n >= 1024 and i < #units do n = n / 1024; i = i + 1 end
                return string.format("%.2f %s", n, units[i])
            end

            local function write_meta(key, size, last)
                local meta_dir = "/var/cache/streamcache/meta"
                os.execute("mkdir -p " .. meta_dir)
                local f = io.open(meta_dir .. "/" .. key .. ".meta", "wb")
                if not f then return end
                f:write("size=" .. tostring(size or 0) .. "\n")
                f:write("last_access=" .. tostring(last or ngx.now()) .. "\n")
                f:close()
            end

            local function b64url_decode(input)
                input = input:gsub('-', '+'):gsub('_', '/')
                local pad = #input % 4
                if pad > 0 then input = input .. string.rep('=', 4 - pad) end
                return ngx.decode_base64(input)
            end

            local function file_exists(p) local f=io.open(p,"rb"); if f then f:close(); return true end return false end
            local function file_size(p) local f=io.open(p,"rb"); if not f then return 0 end local sz=f:seek("end"); f:close(); return sz or 0 end
            local function key_from_url(u) return ngx.md5(u) end

            -- split "authority" into host + port (supports IPv6)
            local function split_hostport(authority, scheme)
                if not authority or authority == "" then return nil, nil end
                -- IPv6 literal
                local h, p = authority:match("^%[([^%]]+)%]:(%d+)$")
                if h then return h, tonumber(p) end
                h = authority:match("^%[([^%]]+)%]$"); if h then
                    return h, (scheme == "https" and 443 or 80)
                end
                -- host:port
                h, p = authority:match("^([^:]+):(%d+)$")
                if h then return h, tonumber(p) end
                -- host only
                return authority, (scheme == "https" and 443 or 80)
            end

            -- robust URL parser: returns scheme, host, port, path, host_header
            local function parse_url(u)
                if not u then return nil end
                local scheme, rest = u:match("^(https?)://(.+)$")
                if not scheme then return nil end
                local authority, path = rest:match("^([^/]+)(/.*)$")
                authority = authority or rest
                path = path or "/"
                local host, port = split_hostport(authority, scheme)
                if not host then return nil end
                local default = (scheme == "https" and 443 or 80)
                port = port or default
                local host_header = (port == default) and host or (host .. ":" .. tostring(port))
                return scheme, host, port, path, host_header
            end

            -- normalize Location into absolute URL
            local function resolve_location(current, scheme, host, loc)
                if not loc or loc == "" then return nil end
                -- absolute
                if loc:match("^https?://") then return loc end
                -- scheme-relative: //host[:port]/path
                if loc:match("^//") then return scheme .. ":" .. loc end
                -- authority-only: host[:port]/path
                if loc:match("^[^/]+:%d+/.") or loc:match("^[^/]+/") then
                    return scheme .. "://" .. loc
                end
                -- root-relative
                if loc:sub(1,1) == "/" then
                    return scheme .. "://" .. host .. loc
                end
                -- relative (append to current dir)
                local base = current:match("^(https?://[^?]+)")
                local dir = base and base:match("(.*/)") or (scheme .. "://" .. host .. "/")
                return dir .. loc
            end

            -- Follow redirects (HEAD then GET Range:0- fallback) -> final absolute URL
            local function follow_redirects(url, max_hops)
                local ssl_verify = (os.getenv("DISABLE_SSL_VERIFY") ~= "1")
                local current = (url or ""):gsub("^%s+", ""):gsub("[%s\r\n]+$", "")
                for _=1,(max_hops or 5) do
                    local httpc = http.new()
                    httpc:set_timeouts(3000, 3000, 3000)

                    -- parse
                    local scheme, host, port, path, host_header
                    do
                        local sch, rest = current:match("^(https?)://(.+)$")
                        if not sch then return nil, "bad_url" end
                        scheme = sch
                        local authority, pth = rest:match("^([^/]+)(/.*)$")
                        authority = authority or rest
                        path = pth or "/"
                        host, port = split_hostport(authority, scheme)
                        if not host then return nil, "bad_url" end
                        local def = (scheme == "https" and 443 or 80)
                        port = port or def
                        host_header = (port == def) and host or (host .. ":" .. tostring(port))
                    end

                    local ok, err = httpc:connect(host, port)
                    if not ok then httpc:close(); return nil, "connect:"..tostring(err) end
                    if scheme == "https" then
                        local ok2, err2 = httpc:ssl_handshake(nil, host, ssl_verify)
                        if not ok2 then httpc:close(); return nil, "tls:"..tostring(err2) end
                    end

                    local headers = { ["Host"] = host_header, ["User-Agent"] = "EmbyStreamCache/1.0", ["Referer"] = url }
                    local res, rerr = httpc:request{ method = "HEAD", path = path, headers = headers }
                    if not res or res.status == 405 then
                        headers["Range"] = "bytes=0-0"
                        res, rerr = httpc:request{ method = "GET", path = path, headers = headers }
                    end
                    if not res then httpc:close(); return nil, "request:"..tostring(rerr) end

                    if res.status == 301 or res.status == 302 or res.status == 303 or res.status == 307 or res.status == 308 then
                        local loc = res.headers and (res.headers["Location"] or res.headers["location"])
                        httpc:close()
                        local next_url = resolve_location(current, scheme, host_header, loc)
                        if not next_url then return nil, "bad_redirect" end
                        current = next_url
                    elseif res.status >= 200 and res.status < 300 then
                        httpc:close()
                        return current, nil
                    else
                        httpc:close()
                        return nil, "status_" .. tostring(res.status)
                    end
                end
                return nil, "too_many_redirects"
            end

            -- Tee: stream upstream -> client and -> file (for no-Range or Range: bytes=0-)
            local function tee_stream(final_url, dest_path, key, use_range_0)
                final_url = (final_url or ""):gsub("^%s+", ""):gsub("[%s\r\n]+$", "")
                local scheme, host, port, path, host_header = parse_url(final_url)
                if not scheme then
                    ngx.log(ngx.WARN, "[streamcache] tee parse failed url=", tostring(final_url))
                    return ngx.exit(ngx.HTTP_BAD_GATEWAY)
                end
                local ssl_verify = (os.getenv("DISABLE_SSL_VERIFY") ~= "1")
                local httpc = http.new()
                httpc:set_timeouts(5000, 5000, 0)

                local ok, err = httpc:connect(host, port)
                if not ok then ngx.log(ngx.WARN, "[streamcache] tee connect failed: ", tostring(err)); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
                if scheme == "https" then
                    local ok2, err2 = httpc:ssl_handshake(nil, host, ssl_verify)
                    if not ok2 then ngx.log(ngx.WARN, "[streamcache] tee TLS failed: ", tostring(err2)); httpc:close(); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
                end

                local headers = { ["Host"] = host_header, ["User-Agent"] = "EmbyStreamCache/1.0", ["Referer"] = ngx.var.scheme .. "://" .. ngx.var.host }
                if use_range_0 then headers["Range"] = "bytes=0-" end

                local res, rerr = httpc:request{ method = "GET", path = path, headers = headers }
                if not res then ngx.log(ngx.WARN, "[streamcache] tee request failed: ", tostring(rerr)); httpc:close(); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
                if not (res.status == 200 or res.status == 206) then
                    ngx.log(ngx.WARN, "[streamcache] tee status not OK: ", res.status)
                    httpc:close()
                    return ngx.exit(ngx.HTTP_BAD_GATEWAY)
                end

                -- Prepare response headers to client
                local hcopy = {}
                for k,v in pairs(res.headers or {}) do
                    local kl = string.lower(k)
                    if kl ~= "transfer-encoding" and kl ~= "connection" and kl ~= "keep-alive"
                       and kl ~= "proxy-authenticate" and kl ~= "proxy-authorization"
                       and kl ~= "te" and kl ~= "trailer" and kl ~= "upgrade" then
                        hcopy[k] = v
                    end
                end
                hcopy["Accept-Ranges"] = "bytes"
                ngx.status = res.status
                for k,v in pairs(hcopy) do ngx.header[k] = v end
                ngx.send_headers()

                -- Open temp file
                os.execute("mkdir -p /var/cache/streamcache/tmp")
                local tmp = "/var/cache/streamcache/tmp/" .. key .. ".part"
                local f = io.open(tmp, "wb")
                if not f then ngx.log(ngx.ERR, "[streamcache] tee cannot open temp: ", tmp); httpc:close(); return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end

                local total = 0
                local client_alive = true

                if res.body_reader then
                    while true do
                        local chunk, cerr = res.body_reader(8192)
                        if cerr then
                            ngx.log(ngx.WARN, "[streamcache] tee read error: ", tostring(cerr))
                            f:close(); os.remove(tmp); httpc:close(); return ngx.exit(ngx.HTTP_BAD_GATEWAY)
                        end
                        if not chunk then break end
                        total = total + #chunk
                        f:write(chunk)
                        if client_alive then
                            local okp = pcall(ngx.print, chunk)
                            if not okp then client_alive = false else ngx.flush(true) end
                        end
                    end
                elseif res.body then
                    total = #res.body
                    f:write(res.body)
                    if client_alive then pcall(ngx.print, res.body); ngx.flush(true) end
                end

                f:flush(); f:close()
                httpc:close()

                if total > 0 then
                    os.rename(tmp, dest_path)
                    local ts = ngx.now()
                    write_meta(key, total, ts)
                    ngx.shared.access:set(key, ts)
                    if VERBOSE then ngx.log(ngx.NOTICE, "[streamcache] tee complete key=", key, " size=", b2human(total)) end
                else
                    os.remove(tmp)
                    ngx.log(ngx.WARN, "[streamcache] tee produced 0 bytes; not committing key=", key)
                end
                return
            end
            -- =====================

            local inflight = ngx.shared.inflight
            local access   = ngx.shared.access
            local resolved = ngx.shared.resolved

            -- Decode Base64URL
            local b64  = ngx.var.b64
            local orig = b64 and b64url_decode(b64) or nil
            if not orig or not orig:match("^https?://") then
                ngx.log(ngx.WARN, "[streamcache] bad request (invalid or non-http URL)")
                return ngx.exit(ngx.HTTP_BAD_REQUEST)
            end
            orig = orig:gsub("^%s+", ""):gsub("[%s\r\n]+$", "")

            -- Optional SSRF protection
            local allowed = os.getenv("ALLOWED_HOSTS")
            if allowed and allowed ~= "" then
                local host = orig:match("^https?://([^/]+)")
                local ok = false
                for h in allowed:gmatch("[^,%s]+") do if host == h then ok = true; break end end
                if not ok then
                    ngx.log(ngx.WARN, "[streamcache] blocked host: ", host)
                    ngx.status = ngx.HTTP_FORBIDDEN
                    ngx.say("Host not allowed")
                    return
                end
            end

            local files_dir = "/var/cache/streamcache/files"
            os.execute("mkdir -p " .. files_dir .. " /var/cache/streamcache/tmp /var/cache/streamcache/meta")

            local key = key_from_url(orig)
            local final_path = files_dir .. "/" .. key

            local function update_last_access()
                local ts = ngx.now()
                access:set(key, ts)
                write_meta(key, file_size(final_path), ts)
            end

            -- HIT (with zero-byte guard)
            if file_exists(final_path) then
                local sz = file_size(final_path)
                if sz <= 0 then
                    ngx.log(ngx.WARN, "[streamcache] zero-byte cached file; purging key=", key)
                    os.remove(final_path)
                    os.remove("/var/cache/streamcache/meta/" .. key .. ".meta")
                    inflight:delete(key)
                else
                    ngx.header["X-Cache"] = "HIT"
                    if VERBOSE then ngx.log(ngx.INFO, "[streamcache] HIT key=", key, " size=", b2human(sz)) end
                    update_last_access()
                    return ngx.exec("/cache/" .. key)
                end
            end

            -- Resolve final CDN URL (cached briefly)
            local function get_final_url_for_key()
                local cached = resolved:get(key)
                if cached and cached ~= "" then return cached end
                local fu, ferr = follow_redirects(orig, 5)
                if not fu then
                    ngx.log(ngx.WARN, "get_final_url_for_key(): [streamcache] redirect resolution failed: ", tostring(ferr))
                    ngx.status = ngx.HTTP_BAD_GATEWAY
                    ngx.header["Content-Type"] = "text/plain"
                    ngx.say("Upstream auth redirect failed; see proxy logs.")
                    return nil
                end
                resolved:set(key, fu, RESOLVE_TTL)
                return fu
            end

            local final_url = get_final_url_for_key()
            if not final_url then return end  -- 502 already returned

            -- Determine if we can tee this request
            local req_range = ngx.req.get_headers()["Range"]
            local tee_ok, use_range_0 = false, false
            if not req_range or req_range == "" then
                tee_ok, use_range_0 = true, false
            else
                local s, e = req_range:match("^bytes=(%d+)%-(%d*)$")
                if s and tonumber(s) == 0 and (not e or e == "") then
                    tee_ok, use_range_0 = true, true
                end
            end

            if tee_ok then
                local added = ngx.shared.inflight:add(key, true, 900)
                if not added then
                    -- Another tee in progress â€” proxy (no cache) but keep client on proxy
                    ngx.header["X-Cache"] = "MISS"
                    ngx.var.upstream_url = final_url
                    if VERBOSE then ngx.log(ngx.INFO, "[streamcache] tee busy; simple proxy key=", key) end
                    return ngx.exec("@passthrough")
                end
                -- Single connection: upstream -> client & file
                return tee_stream(final_url, final_path, key, use_range_0)
            else
                -- Non-teeable range: strictly proxy the resolved final URL
                ngx.header["X-Cache"] = "MISS"
                ngx.var.upstream_url = final_url
                if VERBOSE then ngx.log(ngx.INFO, "[streamcache] non-tee range; proxy only key=", key, " range=", tostring(req_range)) end
                return ngx.exec("@passthrough")
            end
        }
    }

    # Strict proxy for non-tee paths or when tee is busy
    location @passthrough {
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $proxy_host;
        proxy_set_header User-Agent "EmbyStreamCache/1.0";
        proxy_intercept_errors off;

        # Forward Range header to origin
        proxy_set_header Range $http_range;

        # SNI for HTTPS variable upstreams
        proxy_ssl_server_name on;
        proxy_ssl_name $proxy_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;

        proxy_pass_request_headers on;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;

        proxy_pass $upstream_url;
    }
}

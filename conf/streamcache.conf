server {
    listen 8080;
    server_name _;

    # Carry decoded upstream URL to proxy_pass when needed
    set $upstream_url "";

    # Serve cached files directly; Nginx static supports Range natively
    location /cache/ {
        internal;
        alias /var/cache/streamcache/files/;
        add_header Accept-Ranges bytes always;
    }

    # Main endpoint: /u/<BASE64URL-ENCODED-ORIGINAL-URL>
    location ~ ^/u/(?<b64>[-_A-Za-z0-9=]+)$ {
        content_by_lua_block {
          local ngx  = ngx
          local os   = os
          local http = require "resty.http"

          -- ===================== Config =====================
          local VERBOSE        = (os.getenv("LOG_VERBOSE") == "1")
          local RESOLVE_TTL    = tonumber(os.getenv("RESOLVE_TTL") or "") or 600
          local RANGE_TEE_THRESHOLD   = tonumber(os.getenv("RANGE_TEE_THRESHOLD") or "") or 0 -- bytes
          local PROGRESS_FLUSH_BYTES  = tonumber(os.getenv("PROGRESS_FLUSH_BYTES") or "") or 262144 -- 256 KiB
          local FOLLOWER_WAIT_MAX     = tonumber(os.getenv("FOLLOWER_WAIT_MAX") or "") or 600     -- seconds
          local FOLLOWER_POLL_MS      = tonumber(os.getenv("FOLLOWER_POLL_MS") or "") or 50       -- ms
          local SSL_VERIFY            = (os.getenv("DISABLE_SSL_VERIFY") ~= "1")

          -- ===================== Helpers =====================
          local function b2human(n)
            if not n or n < 0 then return "0 B" end
            local units = {"B","KB","MB","GB","TB","PB"}
            local i = 1
            while n >= 1024 and i < #units do n = n / 1024; i = i + 1 end
            return string.format("%.2f %s", n, units[i])
          end

          local function write_meta(key, size, last)
            local meta_dir = "/var/cache/streamcache/meta"
            os.execute("mkdir -p " .. meta_dir)
            local f = io.open(meta_dir .. "/" .. key .. ".meta", "wb")
            if not f then return end
            f:write("size=" .. tostring(size or 0) .. "\n")
            f:write("last_access=" .. tostring(last or ngx.now()) .. "\n")
            f:close()
          end

          local function b64url_decode(input)
            input = input:gsub('-', '+'):gsub('_', '/')
            local pad = #input % 4
            if pad > 0 then input = input .. string.rep('=', 4 - pad) end
            return ngx.decode_base64(input)
          end

          local function file_exists(p)
            local f=io.open(p,"rb"); if f then f:close(); return true end return false
          end
          local function file_size(p)
            local f=io.open(p,"rb"); if not f then return 0 end local sz=f:seek("end"); f:close(); return sz or 0
          end
          local function key_from_url(u) return ngx.md5(u) end

          -- split "authority" into host + port (supports IPv6)
          local function split_hostport(authority, scheme)
            if not authority or authority == "" then return nil, nil end
            -- [v6]:port
            local h, p = authority:match("^%[([^%]]+)%]:(%d+)$")
            if h then return h, tonumber(p) end
            -- [v6]
            h = authority:match("^%[([^%]]+)%]$")
            if h then return h, (scheme == "https" and 443 or 80) end
            -- host:port
            h, p = authority:match("^([^:]+):(%d+)$")
            if h then return h, tonumber(p) end
            -- host
            return authority, (scheme == "https" and 443 or 80)
          end

          -- robust URL parser: returns scheme, host, port, path, host_header
          local function parse_url(u)
            if not u then return nil end
            local scheme, rest = u:match("^(https?)://(.+)$")
            if not scheme then return nil end
            local authority, path = rest:match("^([^/]+)(/.*)$")
            authority = authority or rest
            path = path or "/"
            local host, port = split_hostport(authority, scheme)
            if not host then return nil end
            local default = (scheme == "https" and 443 or 80)
            port = port or default
            local host_header = (port == default) and host or (host .. ":" .. tostring(port))
            return scheme, host, port, path, host_header
          end

          -- normalize Location into absolute URL
          local function resolve_location(current, scheme, host, loc)
            if not loc or loc == "" then return nil end
            if loc:match("^https?://") then return loc end
            if loc:match("^//") then return scheme .. ":" .. loc end
            if loc:match("^[^/]+:%d+/.") or loc:match("^[^/]+/") then
              return scheme .. "://" .. loc
            end
            if loc:sub(1,1) == "/" then
              return scheme .. "://" .. host .. loc
            end
            local base = current:match("^(https?://[^?]+)")
            local dir = base and base:match("(.*/)") or (scheme .. "://" .. host .. "/")
            return dir .. loc
          end

          -- Follow redirects (HEAD then GET Range:0- fallback) -> final absolute URL
          local function follow_redirects(url, max_hops)
            local current = (url or ""):gsub("^%s+", ""):gsub("[%s\r\n]+$", "")
            for _=1,(max_hops or 5) do
              local httpc = http.new()
              httpc:set_timeouts(3000, 3000, 3000)

              local scheme, host, port, path, host_header
              do
                local sch, rest = current:match("^(https?)://(.+)$")
                if not sch then return nil, "bad_url" end
                scheme = sch
                local authority, pth = rest:match("^([^/]+)(/.*)$")
                authority = authority or rest
                path = pth or "/"
                host, port = split_hostport(authority, scheme)
                if not host then return nil, "bad_url" end
                local def = (scheme == "https" and 443 or 80)
                port = port or def
                host_header = (port == def) and host or (host .. ":" .. tostring(port))
              end

              local ok, err = httpc:connect(host, port)
              if not ok then httpc:close(); return nil, "connect:"..tostring(err) end
              if scheme == "https" then
                local ok2, err2 = httpc:ssl_handshake(nil, host, SSL_VERIFY)
                if not ok2 then httpc:close(); return nil, "tls:"..tostring(err2) end
              end

              local headers = { ["Host"]=host_header, ["User-Agent"]="EmbyStreamCache/1.0", ["Referer"]=url }
              local res, rerr = httpc:request{ method = "HEAD", path = path, headers = headers }
              if not res or res.status == 405 then
                headers["Range"] = "bytes=0-0"
                res, rerr = httpc:request{ method = "GET", path = path, headers = headers }
              end
              if not res then httpc:close(); return nil, "request:"..tostring(rerr) end

              if res.status == 301 or res.status == 302 or res.status == 303 or res.status == 307 or res.status == 308 then
                local loc = res.headers and (res.headers["Location"] or res.headers["location"])
                httpc:close()
                local next_url = resolve_location(current, scheme, host_header, loc)
                if not next_url then return nil, "bad_redirect" end
                current = next_url
              elseif res.status >= 200 and res.status < 300 then
                httpc:close()
                return current, nil
              else
                httpc:close()
                return nil, "status_" .. tostring(res.status)
              end
            end
            return nil, "too_many_redirects"
          end

          -- Fetch origin headers quickly (HEAD; fallback GET bytes=0-0)
          local function fetch_origin_headers(final_url)
            local scheme, host, port, path, host_header = parse_url(final_url)
            if not scheme then return {} end
            local httpc = http.new()
            httpc:set_timeouts(3000, 3000, 3000)
            local ok, err = httpc:connect(host, port)
            if not ok then return {} end
            if scheme == "https" then
              local ok2 = httpc:ssl_handshake(nil, host, SSL_VERIFY)
              if not ok2 then httpc:close(); return {} end
            end
            local headers = { ["Host"]=host_header, ["User-Agent"]="EmbyStreamCache/1.0" }
            local res = select(1, httpc:request{ method="HEAD", path=path, headers=headers })
            if (not res) or res.status == 405 then
              headers["Range"] = "bytes=0-0"
              res = select(1, httpc:request{ method="GET", path=path, headers=headers })
            end
            if not res then httpc:close(); return {} end
            local out = {}
            for k,v in pairs(res.headers or {}) do out[string.lower(k)] = v end
            httpc:close()
            return out
          end

          -- ===================== Shared dicts =====================
          local inflight = ngx.shared.inflight
          local access   = ngx.shared.access
          local resolved = ngx.shared.resolved
          local progress = ngx.shared.progress
          local totals   = ngx.shared.totals

          -- ===================== Writers =====================

          -- Tee: upstream -> client & -> file (no Range OR Range: bytes=0-)
          local function tee_stream(final_url, dest_path, key, use_range_0)
            final_url = (final_url or ""):gsub("^%s+", ""):gsub("[%s\r\n]+$", "")
            local scheme, host, port, path, host_header = parse_url(final_url)
            if not scheme then
              ngx.log(ngx.WARN, "[streamcache] tee parse failed url=", tostring(final_url))
              inflight:delete(key)
              return ngx.exit(ngx.HTTP_BAD_GATEWAY)
            end

            local httpc = http.new()
            httpc:set_timeouts(5000, 5000, 0)
            local ok, err = httpc:connect(host, port)
            if not ok then ngx.log(ngx.WARN, "[streamcache] tee connect failed: ", tostring(err)); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            if scheme == "https" then
              local ok2, err2 = httpc:ssl_handshake(nil, host, SSL_VERIFY)
              if not ok2 then ngx.log(ngx.WARN, "[streamcache] tee TLS failed: ", tostring(err2)); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            end

            local headers = { ["Host"]=host_header, ["User-Agent"]="EmbyStreamCache/1.0", ["Referer"]=ngx.var.scheme .. "://" .. ngx.var.host }
            if use_range_0 then headers["Range"] = "bytes=0-" end
            local res, rerr = httpc:request{ method = "GET", path = path, headers = headers }
            if not res then ngx.log(ngx.WARN, "[streamcache] tee request failed: ", tostring(rerr)); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            if not (res.status == 200 or res.status == 206) then
              ngx.log(ngx.WARN, "[streamcache] tee status not OK: ", res.status)
              httpc:close(); inflight:delete(key)
              return ngx.exit(ngx.HTTP_BAD_GATEWAY)
            end

            -- Publish total size (if discoverable) for followers
            do
              local hl = {}
              for k,v in pairs(res.headers or {}) do hl[string.lower(k)] = v end
              local total_size = nil
              if hl["content-range"] then
                local s0, e0, t0 = hl["content-range"]:match("^bytes%s+(%d+)%-(%d+)%/(%d+)$")
                if t0 then total_size = tonumber(t0) end
              end
              if not total_size and hl["content-length"] and (res.status == 200) then
                total_size = tonumber(hl["content-length"])
              end
              if total_size and total_size > 0 then totals:set(key, total_size, 900) end
            end

            -- Prepare response headers to client (pass-through)
            local hcopy = {}
            for k,v in pairs(res.headers or {}) do
              local kl = string.lower(k)
              if kl ~= "transfer-encoding" and kl ~= "connection" and kl ~= "keep-alive"
                 and kl ~= "proxy-authenticate" and kl ~= "proxy-authorization"
                 and kl ~= "te" and kl ~= "trailer" and kl ~= "upgrade" then
                hcopy[k] = v
              end
            end
            hcopy["Accept-Ranges"] = "bytes"
            ngx.status = res.status
            for k,v in pairs(hcopy) do ngx.header[k] = v end
            ngx.send_headers()

            -- Open temp file
            os.execute("mkdir -p /var/cache/streamcache/tmp")
            local tmp = "/var/cache/streamcache/tmp/" .. key .. ".part"
            local f = io.open(tmp, "wb")
            if not f then ngx.log(ngx.ERR, "[streamcache] tee cannot open temp: ", tmp); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end

            local total = 0
            local last_report = 0
            local client_alive = true

            if res.body_reader then
              while true do
                local chunk, cerr = res.body_reader(8192)
                if cerr then
                  ngx.log(ngx.WARN, "[streamcache] tee read error: ", tostring(cerr))
                  f:close(); os.remove(tmp); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY)
                end
                if not chunk then break end
                total = total + #chunk
                f:write(chunk)

                if (total - last_report) >= PROGRESS_FLUSH_BYTES then
                  f:flush()
                  progress:set(key, total, 900)
                  last_report = total
                end

                if client_alive then
                  local okp = pcall(ngx.print, chunk)
                  if not okp then client_alive = false else ngx.flush(true) end
                end
              end
            elseif res.body then
              total = #res.body
              f:write(res.body)
              f:flush()
              progress:set(key, total, 900)
              if client_alive then pcall(ngx.print, res.body); ngx.flush(true) end
            end

            f:flush()
            progress:set(key, total, 900)  -- final
            f:close()
            httpc:close()

            if total > 0 then
              os.rename(tmp, dest_path)
              local ts = ngx.now()
              write_meta(key, total, ts)
              access:set(key, ts)
              if VERBOSE then ngx.log(ngx.NOTICE, "[streamcache] tee complete key=", key, " size=", b2human(total)) end
            else
              os.remove(tmp)
              ngx.log(ngx.WARN, "[streamcache] tee produced 0 bytes; not committing key=", key)
            end

            inflight:delete(key)
            return
          end

          -- Tee with "near-start" window: fetch from 0-, cache full file, serve only requested subrange
          local function tee_stream_range_window(final_url, dest_path, key, client_start, client_end)
            final_url = (final_url or ""):gsub("^%s+", ""):gsub("[%s\r\n]+$", "")
            local scheme, host, port, path, host_header = parse_url(final_url)
            if not scheme then
              ngx.log(ngx.WARN, "[streamcache] tee-window parse failed url=", tostring(final_url))
              inflight:delete(key)
              return ngx.exit(ngx.HTTP_BAD_GATEWAY)
            end

            local httpc = http.new()
            httpc:set_timeouts(5000, 5000, 0)
            local ok, err = httpc:connect(host, port)
            if not ok then ngx.log(ngx.WARN, "[streamcache] tee-window connect failed: ", tostring(err)); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            if scheme == "https" then
              local ok2, err2 = httpc:ssl_handshake(nil, host, SSL_VERIFY)
              if not ok2 then ngx.log(ngx.WARN, "[streamcache] tee-window TLS failed: ", tostring(err2)); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            end

            -- Ask origin for Range:0- so we get total length and a rangeable stream
            local headers = { ["Host"]=host_header, ["User-Agent"]="EmbyStreamCache/1.0",
                              ["Referer"]=ngx.var.scheme .. "://" .. ngx.var.host,
                              ["Range"]="bytes=0-" }
            local res, rerr = httpc:request{ method = "GET", path = path, headers = headers }
            if not res then ngx.log(ngx.WARN, "[streamcache] tee-window request failed: ", tostring(rerr)); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY) end
            if not (res.status == 200 or res.status == 206) then
              ngx.log(ngx.WARN, "[streamcache] tee-window status not OK: ", res.status)
              httpc:close(); inflight:delete(key)
              return ngx.exit(ngx.HTTP_BAD_GATEWAY)
            end

            -- Determine total size and publish for followers
            local headers_l = {}
            for k,v in pairs(res.headers or {}) do headers_l[string.lower(k)] = v end
            local total_size = nil
            if headers_l["content-range"] then
              local s0, e0, t0 = headers_l["content-range"]:match("^bytes%s+(%d+)%-(%d+)%/(%d+)$")
              if s0 and tonumber(s0) == 0 and e0 and t0 then total_size = tonumber(t0) end
            end
            if not total_size and headers_l["content-length"] and res.status == 200 then
              total_size = tonumber(headers_l["content-length"])
            end
            if total_size and total_size > 0 then totals:set(key, total_size, 900) end
            if not total_size or total_size <= 0 then
              httpc:close(); inflight:delete(key)
              ngx.header["X-Cache"] = "MISS"
              ngx.var.upstream_url = final_url
              if VERBOSE then ngx.log(ngx.INFO, "[streamcache] tee-window unknown total size; proxy only key=", key) end
              return ngx.exec("@passthrough")
            end

            -- Compute outbound client range [send_start .. send_end]
            local send_start = math.max(0, tonumber(client_start) or 0)
            local send_end   = tonumber(client_end)
            if not send_end or send_end > (total_size - 1) then send_end = total_size - 1 end
            if send_start > send_end then
              httpc:close(); inflight:delete(key)
              ngx.header["Content-Range"] = string.format("bytes */%d", total_size)
              return ngx.exit(ngx.HTTP_REQUESTED_RANGE_NOT_SATISFIABLE)
            end
            local send_len = (send_end - send_start + 1)

            -- Prepare 206 headers to client; copy safe headers
            local hcopy = {}
            for k,v in pairs(res.headers or {}) do
              local kl = string.lower(k)
              if kl == "content-type" or kl == "etag" or kl == "last-modified" or kl == "content-disposition" then
                hcopy[k] = v
              end
            end
            hcopy["Accept-Ranges"] = "bytes"
            hcopy["Content-Range"] = string.format("bytes %d-%d/%d", send_start, send_end, total_size)
            hcopy["Content-Length"] = tostring(send_len)
            ngx.status = ngx.HTTP_PARTIAL_CONTENT
            for k,v in pairs(hcopy) do ngx.header[k] = v end
            ngx.send_headers()

            -- Open temp file
            os.execute("mkdir -p /var/cache/streamcache/tmp")
            local tmp = "/var/cache/streamcache/tmp/" .. key .. ".part"
            local f = io.open(tmp, "wb")
            if not f then ngx.log(ngx.ERR, "[streamcache] tee-window cannot open temp: ", tmp); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) end

            local total_written = 0
            local last_report = 0
            local sent = 0
            local pos = 0 -- absolute position of next byte from origin in the stream

            local function maybe_send_slice(chunk, chunk_start)
              local chunk_len = #chunk
              local chunk_end = chunk_start + chunk_len - 1
              if chunk_end < send_start or chunk_start > send_end then return 0 end
              local from = math.max(send_start - chunk_start, 0) + 1         -- 1-based
              local to   = math.min(send_end - chunk_start + 1, chunk_len)   -- 1-based inclusive
              local slice = chunk:sub(from, to)
              if #slice > 0 then
                local okp = pcall(ngx.print, slice)
                if okp then ngx.flush(true) end
              end
              return #slice
            end

            if res.body_reader then
              while true do
                local chunk, cerr = res.body_reader(8192)
                if cerr then
                  ngx.log(ngx.WARN, "[streamcache] tee-window read error: ", tostring(cerr))
                  f:close(); os.remove(tmp); httpc:close(); inflight:delete(key); return ngx.exit(ngx.HTTP_BAD_GATEWAY)
                end
                if not chunk then break end
                total_written = total_written + #chunk
                f:write(chunk)

                if (total_written - last_report) >= PROGRESS_FLUSH_BYTES then
                  f:flush()
                  progress:set(key, total_written, 900)
                  last_report = total_written
                end

                sent = sent + maybe_send_slice(chunk, pos)
                pos = pos + #chunk
              end
            elseif res.body then
              local chunk = res.body
              total_written = #chunk
              f:write(chunk)
              f:flush()
              progress:set(key, total_written, 900)
              sent = sent + maybe_send_slice(chunk, pos)
              pos = pos + #chunk
            end

            f:flush()
            progress:set(key, total_written, 900)
            f:close()
            httpc:close()

            -- Commit cache if we actually pulled bytes
            if total_written > 0 then
              os.rename(tmp, dest_path)
              local ts = ngx.now()
              write_meta(key, total_written, ts)
              access:set(key, ts)
              if VERBOSE then
                ngx.log(ngx.NOTICE, "[streamcache] tee-window complete key=", key,
                       " size=", b2human(total_written),
                       " served=", tostring(sent), "B range=", tostring(send_start), "-", tostring(send_end))
              end
            else
              os.remove(tmp)
              ngx.log(ngx.WARN, "[streamcache] tee-window produced 0 bytes; not committing key=", key)
            end

            inflight:delete(key)
            return
          end

          -- ===================== Follower (serve from .part) =====================
          local function serve_from_part(final_url, key, req_start, req_end)
            local files_dir = "/var/cache/streamcache/files"
            local tmp = "/var/cache/streamcache/tmp/" .. key .. ".part"

            -- If final already committed, serve HIT
            if file_exists(files_dir .. "/" .. key) then
              ngx.header["X-Cache"] = "HIT"
              return ngx.exec("/cache/" .. key)
            end

            local f = io.open(tmp, "rb")
            if not f then
              -- No .part: fallback to passthrough
              return nil, "no_part"
            end

            -- Try to learn total size (may already be set by writer)
            local total_size = totals:get(key)
            local waited = 0
            while not total_size and waited < 2000 do
              ngx.sleep(0.05); waited = waited + 50
              total_size = totals:get(key)
            end
            if not total_size then
              f:close()
              return nil, "no_total"
            end
            total_size = tonumber(total_size)

            local start = tonumber(req_start) or 0
            local stop  = (req_end and req_end ~= "") and tonumber(req_end) or (total_size - 1)
            if stop > (total_size - 1) then stop = total_size - 1 end
            if start > stop then
              f:close()
              ngx.header["Content-Range"] = string.format("bytes */%d", total_size)
              return ngx.exit(ngx.HTTP_REQUESTED_RANGE_NOT_SATISFIABLE)
            end
            if start > total_size - 1 then
              f:close()
              ngx.header["Content-Range"] = string.format("bytes */%d", total_size)
              return ngx.exit(ngx.HTTP_REQUESTED_RANGE_NOT_SATISFIABLE)
            end

            -- Fetch a few origin headers for content-type/etag friendliness
            local oh = fetch_origin_headers(final_url)

            ngx.status = ngx.HTTP_PARTIAL_CONTENT
            ngx.header["X-Cache"] = "FOLLOW"
            ngx.header["Accept-Ranges"] = "bytes"
            ngx.header["Content-Range"] = string.format("bytes %d-%d/%d", start, stop, total_size)
            ngx.header["Content-Length"] = tostring(stop - start + 1)
            if oh["content-type"] then ngx.header["Content-Type"] = oh["content-type"] end
            if oh["etag"] then ngx.header["ETag"] = oh["etag"] end
            if oh["last-modified"] then ngx.header["Last-Modified"] = oh["last-modified"] end
            if oh["content-disposition"] then ngx.header["Content-Disposition"] = oh["content-disposition"] end
            ngx.send_headers()

            local deadline = ngx.now() + FOLLOWER_WAIT_MAX
            local sent = 0
            local needed = stop - start + 1
            local current_offset = start
            f:seek("set", start)

            local function available_bytes()
              local p = progress:get(key) or 0
              local avail = p - current_offset
              if avail < 0 then avail = 0 end
              local max_need = (stop + 1) - current_offset
              if avail > max_need then avail = max_need end
              return avail
            end

            while sent < needed do
              local avail = available_bytes()
              if avail > 0 then
                local chunk_sz = math.min(avail, 8192)
                local chunk = f:read(chunk_sz)
                if not chunk or #chunk == 0 then
                  ngx.sleep(FOLLOWER_POLL_MS / 1000)
                else
                  local okp = pcall(ngx.print, chunk)
                  if not okp then f:close(); return ngx.exit(ngx.HTTP_OK) end
                  ngx.flush(true)
                  sent = sent + #chunk
                  current_offset = current_offset + #chunk
                end
              else
                if ngx.now() > deadline then
                  f:close()
                  ngx.log(ngx.WARN, "[streamcache] follower timeout key=", key, " offset=", tostring(current_offset))
                  return ngx.exit(ngx.HTTP_GATEWAY_TIMEOUT)
                end
                ngx.sleep(FOLLOWER_POLL_MS / 1000)
              end
            end

            f:close()
            return
          end

          -- ===================== Main =====================

          -- Decode Base64URL
          local b64 = ngx.var.b64
          local orig = b64 and b64url_decode(b64) or nil
          if not orig or not orig:match("^https?://") then
            ngx.log(ngx.WARN, "[streamcache] bad request (invalid or non-http URL)")
            return ngx.exit(ngx.HTTP_BAD_REQUEST)
          end
          orig = orig:gsub("^%s+", ""):gsub("[%s\r\n]+$", "")

          -- Optional SSRF protection
          local allowed = os.getenv("ALLOWED_HOSTS")
          if allowed and allowed ~= "" then
            local host = orig:match("^https?://([^/]+)")
            local ok = false
            for h in allowed:gmatch("[^,%s]+") do if host == h then ok = true; break end end
            if not ok then
              ngx.log(ngx.WARN, "[streamcache] blocked host: ", host)
              ngx.status = ngx.HTTP_FORBIDDEN
              ngx.say("Host not allowed")
              return
            end
          end

          local files_dir = "/var/cache/streamcache/files"
          os.execute("mkdir -p " .. files_dir .. " /var/cache/streamcache/tmp /var/cache/streamcache/meta")
          local key = key_from_url(orig)
          local final_path = files_dir .. "/" .. key

          local function update_last_access()
            local ts = ngx.now()
            access:set(key, ts)
            write_meta(key, file_size(final_path), ts)
          end

          -- HIT (with zero-byte guard)
          if file_exists(final_path) then
            local sz = file_size(final_path)
            if sz <= 0 then
              ngx.log(ngx.WARN, "[streamcache] zero-byte cached file; purging key=", key)
              os.remove(final_path)
              os.remove("/var/cache/streamcache/meta/" .. key .. ".meta")
              inflight:delete(key)
            else
              ngx.header["X-Cache"] = "HIT"
              if VERBOSE then ngx.log(ngx.INFO, "[streamcache] HIT key=", key, " size=", b2human(sz)) end
              update_last_access()
              return ngx.exec("/cache/" .. key)
            end
          end

          -- Resolve final CDN URL (cached briefly)
          local function get_final_url_for_key()
            local cached = resolved:get(key)
            if cached and cached ~= "" then return cached end
            local fu, ferr = follow_redirects(orig, 5)
            if not fu then
              ngx.log(ngx.WARN, "get_final_url_for_key(): [streamcache] redirect resolution failed: ", tostring(ferr))
              ngx.status = ngx.HTTP_BAD_GATEWAY
              ngx.header["Content-Type"] = "text/plain"
              ngx.say("Upstream auth redirect failed; see proxy logs.")
              return nil
            end
            resolved:set(key, fu, RESOLVE_TTL)
            return fu
          end

          local final_url = get_final_url_for_key()
          if not final_url then return end -- 502 already returned

          -- Determine teeability
          local req_range = ngx.req.get_headers()["Range"]
          local tee_ok, use_range_0 = false, false
          local near_start, near_end = nil, nil

          if not req_range or req_range == "" then
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: no Range header; tee_ok=true")
            tee_ok, use_range_0 = true, false
          else
            local s, e = req_range:match("^bytes=(%d+)%-(%d*)$")
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: parsing Range header req_range=" .. tostring(req_range))
            if s then
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: RANGE_TEE_THRESHOLD=" .. tostring(RANGE_TEE_THRESHOLD) .. " s=" .. tostring(s) .. " e=" .. tostring(e))
              s = tonumber(s)
              e = (e and e ~= "") and tonumber(e) or nil
              if s == 0 and (not e) then
                tee_ok, use_range_0 = true, true
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: tee_ok=true for range s=" .. tostring(s) .. " e=" .. tostring(e))
              elseif RANGE_TEE_THRESHOLD > 0 and s > 0 and s <= RANGE_TEE_THRESHOLD then
                tee_ok, use_range_0, near_start, near_end = true, true, s, e
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: tee_ok=true for range s=" .. tostring(s) .. " e=" .. tostring(e))
              end
            end
          end

          if tee_ok then
            local added = inflight:add(key, true, 900)
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: inflight:add called for key=" .. key)
            if not added then
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: inflight:add failed; tee already in progress for key=" .. key)
              -- Another tee is filling the cache.
              if req_range and req_range ~= "" then
                local s, e = req_range:match("^bytes=(%d+)%-(%d*)$")
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: parsing Range header req_range=" .. tostring(req_range))
                if s then
ngx.log(ngx.NOTICE, "[streamcache] DEBUG: RANGE_TEE_THRESHOLD=" .. tostring(RANGE_TEE_THRESHOLD) .. " s=" .. tostring(s) .. " e=" .. tostring(e))
                  local err = serve_from_part(final_url, key, tonumber(s), (e and e ~= "") and tonumber(e) or nil)
                  if not err then return end  -- served from .part
                  if VERBOSE then ngx.log(ngx.INFO, "[streamcache] follow failed: ", tostring(err), " ; proxy key=", key) end
                end
              end
              -- Fallback: passthrough
              ngx.header["X-Cache"] = "MISS"
              ngx.var.upstream_url = final_url
              if VERBOSE then ngx.log(ngx.INFO, "[streamcache] tee busy; simple proxy key=", key) end
              return ngx.exec("@passthrough")
            end

            -- Single connection: upstream -> client & file
            if near_start then
              return tee_stream_range_window(final_url, final_path, key, near_start, near_end)
            else
              return tee_stream(final_url, final_path, key, use_range_0)
            end
          else
            -- Not teeable: strictly proxy the resolved final URL
            ngx.header["X-Cache"] = "MISS"
            ngx.var.upstream_url = final_url
            if VERBOSE then ngx.log(ngx.INFO, "[streamcache] non-tee range; proxy only key=", key, " range=", tostring(req_range)) end
            return ngx.exec("@passthrough")
          end
        }
    }

    # Strict proxy for non-tee paths or when tee is busy
    location @passthrough {
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $proxy_host;
        proxy_set_header User-Agent "EmbyStreamCache/1.0";
        proxy_intercept_errors off;

        # Forward Range header to origin
        proxy_set_header Range $http_range;

        # SNI for HTTPS variable upstreams
        proxy_ssl_server_name on;
        proxy_ssl_name $proxy_host;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;

        proxy_pass_request_headers on;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;

        proxy_pass $upstream_url;
    }
}
